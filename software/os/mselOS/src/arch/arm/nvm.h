/** @file nvm.h

    Exported definitions for managing eNVM

    A large portion of this file is copied from the "mss_nvm" driver
    generated by Libero SoC. It generates most of the useful code in C
    source and not header files, basically declaring most of the
    functionality "private", so we've elected to copy it into our tree
    and manage it ourselves.

*/
/*
   Copyright 2015, Google Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#ifndef _MSEL_NVM_H_
#define _MSEL_NVM_H_

#include "m2sxxx.h"

/*
 * Indicates that the NVM_write() function should not lock the addressed pages
 * after programming the data.
 */
#define NVM_DO_NOT_LOCK_PAGE    0u

/*
 * Indicates that the NVM_write() function should lock the addressed pages after
 * programming the data.
 */
#define NVM_LOCK_PAGE           1u

/*******************************************************************************
  The nvm_status_t enumeration specifies the possible return values from the
  NVM_write() and NVM_unlock() functions.
  
    NVM_SUCCESS:
      Indicates that the programming was successful.
        
    NVM_PROTECTION_ERROR:
      Indicates that the operation could not be completed because of a
      protection error. This happens when attempting to program a page that was
      set as protected in the hardware flow.
      
    NVM_VERIFY_FAILURE:
      Indicates that one of the verify operations failed.
      
    NVM_PAGE_LOCK_ERROR:
      Indicates that the operation could not complete because one of the pages
      is locked. This may happen if the page was locked during a previous call
      to NVM_write() or if the page was locked in the hardware design flow.
      
    NVM_WRITE_THRESHOLD_ERROR:
      Indicates that the NVM maximum number of programming cycles has been
      reached.
      
    NVM_IN_USE_BY_OTHER_MASTER:
      Indicates that some other MSS AHB Bus Matrix master is accessing the NVM.
      This could be due to the FPGA logic or the system controller programming
      the NVM.
      
    NVM_INVALID_PARAMETER:
      Indicates that one of more of the function parameters has an invalid
      value. This is typically returned when attempting to write or unlock 
      the eNVM for invalid address, data pointer, lock page and more
      eNVM than is available on the device.
 */
typedef enum nvm_status
{
    NVM_SUCCESS = 0,
    NVM_PROTECTION_ERROR,
    NVM_VERIFY_FAILURE,
    NVM_PAGE_LOCK_ERROR,
    NVM_WRITE_THRESHOLD_ERROR,
    NVM_IN_USE_BY_OTHER_MASTER,
    NVM_INVALID_PARAMETER
} nvm_status_t;

/**************************************************************************/
/* Preprocessor definitions                                               */
/**************************************************************************/


/*     eNVM command codes       */
#define PROG_ADS                        0x08000000u  /* One shot program with data in WD */
#define VERIFY_ADS                      0x10000000u  /* One shot verification with data in WD */
#define USER_UNLOCK                     0x13000000u  /* User unlock */

#define BITS_PER_PAGE                   1024u                   /* Number of bits per page */
#define BYTES_PER_PAGE                  (BITS_PER_PAGE / 8u)    /* Number of bytes per page */

#define NVM_OFFSET_SIGNIFICANT_BITS     0x0007FFFFu
#define NVM1_BOTTOM_OFFSET              0x00040000u
#define NVM1_TOP_OFFSET                 0x0007FFFFu

#define PARAM_LOCK_PAGE_FLAG            0x00000002u
#define ACCESS_DENIED_FLAG_CLEAR        0x00000002u

#define PAGES_PER_BLOCK                 2048u

#define NVM_BOTTOM_OFFSET               0x00000000u
#define NVM_TOP_OFFSET                  0x0007FFFFu

#define NVM_BASE_ADDRESS                0x60000000u

#define PAGE_ADDR_MASK                  0xFFFFFF80u

#define BLOCK1_FIRST_WORD_OFFSET        0x00010000u

#define WD_WORD_SIZE                    32u

#define NB_OF_BYTES_IN_A_WORD           4u

#define MAX_512K_OFFSET                 0x00080000u

#define WRITE_ERROR_MASK                (MSS_NVM_VERIFY_FAIL | \
                                            MSS_NVM_EVERIFY_FAIL | \
                                            MSS_NVM_WVERIFY_FAIL | \
                                            MSS_NVM_PEFAIL_LOCK | \
                                            MSS_NVM_WRCNT_OVER | \
                                            MSS_NVM_WR_DENIED)

/*******************************************************************************
 * Combined status definitions
 * Below definitions should be used to decoded the bit encoded status returned 
 * by the function MSS_NVM_get_status().
 */
#define MSS_NVM_BUSY_B                  (1u)                    /* NVM is performing an internal operation */
#define MSS_NVM_VERIFY_FAIL             ((uint32_t)1 << 1u)     /* NVM verify operation failed */
#define MSS_NVM_EVERIFY_FAIL            ((uint32_t)1 << 2u)     /* NVM erase verify operation failed */
#define MSS_NVM_WVERIFY_FAIL            ((uint32_t)1 << 3u)     /* NVM write verify operation failed */
#define MSS_NVM_PEFAIL_LOCK             ((uint32_t)1 << 4u)     /* NVM program / erase operation failed due to page lock */
#define MSS_NVM_WRCNT_OVER              ((uint32_t)1 << 5u)     /* NVM write count overflowed */
#define MSS_NVM_WR_DENIED               ((uint32_t)1 << 18u)    /* NVM write is denied due to protection */

/*******************************************************************************
 * eNVM Block Index values
 */
#define NVM_BLOCK_0                     0u
#define NVM_BLOCK_1                     1u

#ifndef _NVM_OBJECT
/* Don't declare extern if being included by the file that defines these */
extern NVM_TypeDef *const g_nvm[];
extern NVM32_TypeDef *const g_nvm32[];
#endif

/* Function decls */
nvm_status_t request_nvm_access(uint32_t);
nvm_status_t get_ctrl_access(uint32_t, uint32_t);
void release_ctrl_access(void);
uint32_t get_remaining_page_length(uint32_t, uint32_t);
uint32_t wait_nvm_ready(uint32_t);
nvm_status_t get_error_code(uint32_t);

void fill_wd_buffer(const uint8_t*, uint32_t, uint32_t, uint32_t);

uint32_t write_nvm(uint32_t, const uint8_t*, uint32_t, 
			  uint32_t, uint32_t*);

nvm_status_t NVM_unlock(uint32_t, uint32_t);
nvm_status_t NVM_write(uint32_t, const uint8_t*, uint32_t, uint32_t);
nvm_status_t NVM_read(uint8_t*, uint8_t*, uint32_t);
#endif
